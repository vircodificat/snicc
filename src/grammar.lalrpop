use bstr::BString;

use crate::lexer::Token;
use crate::lexer::LexicalError;
use crate::ast;

grammar;

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        "var" => Token::KwVar,
        "print" => Token::KwPrint,
        "exit" => Token::KwExit,
        "ident" => Token::Identifier(<BString>),
        "int" => Token::Integer(<i64>),
        "fn" => Token::KwFn,
        "return" => Token::KwReturn,
        "loop" => Token::KwLoop,
        "if" => Token::KwIf,
        "else" => Token::KwElse,
        "while" => Token::KwWhile,
        "for" => Token::KwFor,
        "in" => Token::KwIn,
        "{" => Token::LCurly,
        "}" => Token::RCurly,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "=" => Token::Eq,
        "==" => Token::EqEq,
        "!=" => Token::NotEq,
        "<" => Token::Lt,
        ">" => Token::Gt,
        "<=" => Token::LtEq,
        ">=" => Token::GtEq,
        ";" => Token::Semicolon,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Mul,
        "/" => Token::Div,
        "," => Token::Comma,
        "." => Token::Dot,
        ".." => Token::DotDot,
    }
}

pub Program: ast::Program = {
    <decls:Declaration*> => ast::Program {
        decls,
    },
}

Declaration: ast::Declaration = {
    "fn" <name:"ident"> "(" <params:FnParamlist> ")" "{"
        <stmts:Statement*>
    "}" => {
        ast::Declaration::Fn(ast::FuncDecl {
            name,
            params,
            stmts,
        })
    },
}

FnParamlist: Vec<BString> = {
    => vec![],
    <paramlist:NonemptyFnParamlist> ","? => paramlist,
}

NonemptyFnParamlist: Vec<BString> = {
    <ident:"ident"> => { vec![ident] },
    <mut paramlist:NonemptyFnParamlist> "," <ident:"ident"> => {
        paramlist.push(ident);
        paramlist
    },
}

Arglist: Vec<ast::Expr> = {
    => vec![],
    <arglist:NonemptyArglist> ","? => arglist,
}

NonemptyArglist: Vec<ast::Expr> = {
    <arg:Expr> => { vec![*arg] },
    <mut arglist:NonemptyArglist> "," <arg:Expr> => {
        arglist.push(*arg);
        arglist
    },
}

Statement: ast::Statement = {
    <name:"ident"> "=" <expr:Expr> ";" => {
        ast::Statement::Assign { name, expr }
    },
    "var" <name:"ident"> "=" <expr:Expr> ";" => {
        ast::Statement::VariableInit { name, expr }
    },
    "var" <name:"ident"> ";" => {
        ast::Statement::Variable { name }
    },
    "print" <expr:Expr> ";" => {
        ast::Statement::Print { expr }
    },
    "exit" ";" => {
        ast::Statement::Exit
    },
    "return" <expr:Expr> ";" => {
        ast::Statement::Ret(expr)
    },
    <expr:Expr> ";" => {
        ast::Statement::Expr(expr)
    },
    "loop" "{"
        <stmts:Statement*>
    "}" => {
        ast::Statement::Loop(stmts)
    },
    "if" <expr:Expr> "{"
        <stmts:Statement*>
    "}" => {
        ast::Statement::If(expr, stmts)
    },
    "while" <expr:Expr> "{"
        <stmts:Statement*>
    "}" => {
        ast::Statement::While(expr, stmts)
    },
    "for" <ident:"ident"> "in" <start:Expr> ".." <end:Expr> "{"
        <stmts:Statement*>
    "}" => {
        ast::Statement::For(ident, start, end, stmts)
    },
}

Expr: Box<ast::Expr> = {
    #[precedence(level="1")]
    Term,

    #[precedence(level="2")] #[assoc(side="left")]
    <lhs:Expr> "*" <rhs:Expr> => {
        Box::new(ast::Expr::BinaryOperation {
            lhs,
            operator: ast::Operator::Mul,
            rhs
        })
    },
    <lhs:Expr> "/" <rhs:Expr> => {
        Box::new(ast::Expr::BinaryOperation {
            lhs,
            operator: ast::Operator::Div,
            rhs
        })
    },

    #[precedence(level="3")] #[assoc(side="left")]
    <lhs:Expr> "+" <rhs:Expr> => {
        Box::new(ast::Expr::BinaryOperation {
            lhs,
            operator: ast::Operator::Add,
            rhs
        })
    },
    <lhs:Expr> "-" <rhs:Expr> => {
        Box::new(ast::Expr::BinaryOperation {
            lhs,
            operator: ast::Operator::Sub,
            rhs
        })
    },

    #[precedence(level="4")] #[assoc(side="left")]
    <lhs:Expr> "==" <rhs:Expr> => {
        Box::new(ast::Expr::BinaryOperation {
            lhs,
            operator: ast::Operator::Eq,
            rhs
        })
    },
    <lhs:Expr> "!=" <rhs:Expr> => {
        Box::new(ast::Expr::BinaryOperation {
            lhs,
            operator: ast::Operator::NotEq,
            rhs
        })
    },
    <lhs:Expr> "<" <rhs:Expr> => {
        Box::new(ast::Expr::BinaryOperation {
            lhs,
            operator: ast::Operator::Lt,
            rhs
        })
    },
}

Term: Box<ast::Expr> = {
    <val:"int"> => {
        Box::new(ast::Expr::LitI64(val))
    },
    <name:"ident"> => {
        Box::new(ast::Expr::Variable(name))
    },
    <fnname:"ident"> "(" <arglist:Arglist> ")" => {
        Box::new(ast::Expr::Call {
            fnname,
            args: arglist,
        })
    },
    "(" <Expr> ")",
}
